<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GoDice Restaurant Game</title>
    <style>
      body {
        font-family: system-ui, Arial, sans-serif;
        margin: 0;
        background: #0b1020;
        color: #f9fafb;
      }
      header {
        padding: 16px 20px;
        border-bottom: 1px solid #111827;
        background: radial-gradient(circle at top, #1f2937, #020617);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      h1 {
        margin: 0;
        font-size: 20px;
      }
      main {
        padding: 16px 20px 32px;
      }

      .btn {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #4b5563;
        background: #111827;
        color: #f9fafb;
        cursor: pointer;
        font-size: 14px;
      }
      .btn[disabled] {
        opacity: 0.4;
        cursor: default;
      }
      .btn-secondary {
        background: #020617;
      }

      .top-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        margin-bottom: 16px;
      }
      #sessionInfo {
        font-size: 14px;
        color: #e5e7eb;
      }

      #diceList {
        margin-top: 12px;
      }
      .card {
        border: 1px solid #374151;
        background: #020617;
        border-radius: 10px;
        padding: 12px;
        margin: 10px 0;
        max-width: 480px;
        transition: opacity 0.3s ease;
      }
      .card h3 {
        margin: 0 0 4px 0;
        font-size: 16px;
      }
      .line {
        font-size: 13px;
        color: #e5e7eb;
        margin: 2px 0;
      }
      .muted {
        opacity: 0.5;
      }

      /* Start Game overlay */
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .overlay-card {
        background: #020617;
        border-radius: 12px;
        padding: 20px;
        width: 320px;
        border: 1px solid #4b5563;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      }
      .overlay-card h2 {
        margin: 0 0 8px 0;
        font-size: 18px;
      }
      .overlay-card p {
        margin: 0 0 12px 0;
        font-size: 13px;
        color: #e5e7eb;
      }
      .field {
        margin-bottom: 10px;
      }
      .field label {
        display: block;
        font-size: 13px;
        margin-bottom: 2px;
      }
      .field input,
      .field select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid #4b5563;
        background: #020617;
        color: #f9fafb;
        font-size: 13px;
      }
      .error-text {
        color: #fca5a5;
        font-size: 12px;
        min-height: 16px;
      }
      .overlay-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 12px;
      }

      /* Guidelines modal */
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1100;
      }
      .modal {
        background: #020617;
        border-radius: 12px;
        padding: 20px;
        width: 360px;
        border: 1px solid #4b5563;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      }
      .modal h3 {
        margin: 0 0 8px 0;
        font-size: 16px;
      }
      .modal p,
      .modal ul {
        font-size: 13px;
        color: #e5e7eb;
        margin: 4px 0;
      }
      .modal ul {
        padding-left: 18px;
      }
      .modal-footer {
        margin-top: 12px;
        text-align: right;
      }

      /* Visual dice area */
      .faces-section-title {
        margin: 20px 0 8px 0;
        font-size: 16px;
      }
      #diceFaces {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
      }
      .dice-face {
        text-align: center;
        color: #e5e7eb;
      }
      .dice-face-label {
        font-size: 14px;
        margin-bottom: 4px;
      }
      .dice-square {
        width: 80px;
        height: 80px;
        border-radius: 12px;
        border: 2px solid #e5e7eb;
        background: #111827;
        box-shadow: 0 0 0 2px #1f2937;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 4px;
      }
      .dice-square-value {
        font-size: 32px;
        font-weight: 700;
      }
      .dice-face-value {
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- Start Game Overlay -->
    <div id="startOverlay" class="overlay">
      <div class="overlay-card">
        <h2>Start Dice Game</h2>
        <p>Enter details for this table before starting the game.</p>

        <div class="field">
          <label for="tableInput">Table number</label>
          <input id="tableInput" type="text" placeholder="e.g. 12" />
        </div>

        <div class="field">
          <label for="checkInput">Check number</label>
          <input id="checkInput" type="text" placeholder="e.g. 43821" />
        </div>

        <div class="field">
          <label for="managerSelect">Manager</label>
          <select id="managerSelect">
            <option value="">Select manager</option>
          </select>
        </div>

        <div id="overlayError" class="error-text"></div>

        <div class="overlay-actions">
          <button id="guidelinesBtn" class="btn btn-secondary" type="button">
            Guidelines
          </button>
          <button id="startSessionBtn" class="btn" type="button">
            Start Game
          </button>
        </div>
      </div>
    </div>

    <!-- Guidelines Modal -->
    <div id="guidelinesBackdrop" class="modal-backdrop">
      <div class="modal">
        <h3>Game Guidelines</h3>
        <p>This information is for servers and managers.</p>
        <ul>
          <li>
            Guests can play once at the end of their meal, before payment.
          </li>
          <li>
            Use the physical GoDice provided; do not substitute other dice.
          </li>
          <li>Each roll is tied to this table and check number for records.</li>
          <li>
            Rewards are applied based on the rolled value according to internal
            policy.
          </li>
          <li>
            Do not change table or check after starting; end the game and start
            a new one if needed.
          </li>
        </ul>
        <div class="modal-footer">
          <button id="closeGuidelinesBtn" class="btn" type="button">
            Close
          </button>
        </div>
      </div>
    </div>

    <header>
      <h1>GoDice Restaurant Game</h1>
      <button id="guidelinesTopBtn" class="btn btn-secondary" type="button">
        Guidelines
      </button>
    </header>

    <main>
      <div class="top-row">
        <div id="sessionInfo">No active game session</div>
        <button
          id="endSessionBtn"
          class="btn btn-secondary"
          type="button"
          disabled
        >
          End Game
        </button>
        <button id="connectBtn" class="btn" type="button" disabled>
          Connect Die
        </button>
      </div>

      <section>
        <h2 style="margin: 0 0 8px 0; font-size: 16px">Connected Dice</h2>
        <div id="diceList"></div>
      </section>

      <!-- NEW: visual dice area (like your sketch) -->
      <section>
        <h2 class="faces-section-title">Last Roll by Die</h2>
        <div id="diceFaces"></div>
      </section>
    </main>

    <script src="godice.js"></script>
    <script>
      /**********************************
       * SESSION STATE (in memory only)
       **********************************/
      const sessionState = {
        active: false,
        current: null, // { id, startedAt, tableNumber, checkNumber, managerId, managerName }
        rolls: [], // { timestamp, tableNumber, checkNumber, managerId, managerName, dieId, dieLabel, face }
      };

      /**********************************
       * DOM ELEMENTS
       **********************************/
      const startOverlay = document.getElementById("startOverlay");
      const tableInput = document.getElementById("tableInput");
      const checkInput = document.getElementById("checkInput");
      const managerSelect = document.getElementById("managerSelect");
      const startSessionBtn = document.getElementById("startSessionBtn");
      const overlayError = document.getElementById("overlayError");

      const guidelinesBackdrop = document.getElementById("guidelinesBackdrop");
      const guidelinesBtn = document.getElementById("guidelinesBtn");
      const guidelinesTopBtn = document.getElementById("guidelinesTopBtn");
      const closeGuidelinesBtn = document.getElementById("closeGuidelinesBtn");

      const sessionInfo = document.getElementById("sessionInfo");
      const endSessionBtn = document.getElementById("endSessionBtn");
      const connectBtn = document.getElementById("connectBtn");
      const diceList = document.getElementById("diceList");
      const diceFaces = document.getElementById("diceFaces");

      function updateConnectButtonLabel() {
        if (!diceList) return;

        if (diceList.children.length === 0) {
          connectBtn.textContent = "Connect Die";
        } else {
          connectBtn.textContent = "Connect Another Die";
        }
      }

      /**********************************
       * MANAGERS (static list for now)
       **********************************/
      const MANAGERS = [
        { id: "ankush", name: "Ankush Punhani" },
        { id: "pralosh", name: "Pralosh Rajbhandari" },
        { id: "mgr_nj_1", name: "Manager NJ 01" },
      ];

      function populateManagerDropdown() {
        MANAGERS.forEach((m) => {
          const opt = document.createElement("option");
          opt.value = m.id;
          opt.textContent = m.name;
          managerSelect.appendChild(opt);
        });
      }

      /**********************************
       * GUIDELINES MODAL LOGIC
       **********************************/
      function openGuidelines() {
        guidelinesBackdrop.style.display = "flex";
      }
      function closeGuidelines() {
        guidelinesBackdrop.style.display = "none";
      }
      guidelinesBtn.addEventListener("click", openGuidelines);
      guidelinesTopBtn.addEventListener("click", openGuidelines);
      closeGuidelinesBtn.addEventListener("click", closeGuidelines);
      guidelinesBackdrop.addEventListener("click", (e) => {
        if (e.target === guidelinesBackdrop) closeGuidelines();
      });

      /**********************************
       * SESSION HELPERS
       **********************************/
      function formatSessionInfo(session) {
        return `Table ${session.tableNumber} • Check ${session.checkNumber} • Manager ${session.managerName}`;
      }

      function startSession() {
        const table = tableInput.value.trim();
        const check = checkInput.value.trim();
        const managerId = managerSelect.value;

        if (!table || !check || !managerId) {
          overlayError.textContent =
            "Please fill table, check, and manager to start.";
          return;
        }

        const manager = MANAGERS.find((m) => m.id === managerId);
        if (!manager) {
          overlayError.textContent = "Please select a valid manager.";
          return;
        }

        overlayError.textContent = "";

        const sessionId = "sess_" + Date.now();
        const startedAt = new Date().toISOString();

        sessionState.active = true;
        sessionState.current = {
          id: sessionId,
          startedAt,
          tableNumber: table,
          checkNumber: check,
          managerId: manager.id,
          managerName: manager.name,
        };
        sessionState.rolls = []; // reset in-memory rolls

        console.log("[SESSION STARTED]", sessionState.current);

        // Reset labels and dice UI at the start of each game
        resetLabelGen();
        clearAllDiceUI();

        // Update UI
        sessionInfo.textContent = formatSessionInfo(sessionState.current);
        startOverlay.style.display = "none";
        connectBtn.disabled = false;
        endSessionBtn.disabled = false;
      }

      function endSession() {
        if (!sessionState.active || !sessionState.current) return;

        const endedAt = new Date().toISOString();
        const summary = {
          ...sessionState.current,
          endedAt,
          rolls: [...sessionState.rolls],
        };

        console.log("[SESSION ENDED]", summary);

        // Disconnect all dice at end of game
        disconnectAllDice();

        // Reset session state
        sessionState.active = false;
        sessionState.current = null;
        sessionState.rolls = [];

        // Update UI
        sessionInfo.textContent = "No active game session";
        connectBtn.disabled = true;
        endSessionBtn.disabled = false; // keep enabled until dice disconnect done, then overlay appears

        // Show overlay again for next table
        startOverlay.style.display = "flex";
        tableInput.value = "";
        checkInput.value = "";
        managerSelect.value = "";
        overlayError.textContent = "";
      }

      endSessionBtn.addEventListener("click", endSession);
      startSessionBtn.addEventListener("click", startSession);

      /**********************************
       * ROLL RECORDING
       **********************************/
      function recordRoll(diceId, dieLabel, face) {
        if (!sessionState.active || !sessionState.current) {
          console.log("[ROLL IGNORED] No active session", {
            diceId,
            dieLabel,
            face,
          });
          return;
        }

        const now = new Date().toISOString();
        const s = sessionState.current;

        const record = {
          timestamp: now,
          tableNumber: s.tableNumber,
          checkNumber: s.checkNumber,
          managerId: s.managerId,
          managerName: s.managerName,
          dieId: diceId,
          dieLabel,
          face: Number(face) || 0,
        };

        sessionState.rolls.push(record);
        console.log("[ROLL RECORDED]", record);
      }

      /**********************************
       * DICE CONNECTION LOGIC
       **********************************/
      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
      function shortId(id) {
        return (id || "").slice(0, 6) + "…";
      }

      // LABEL GENERATOR (reset to A/B each game)
      function* labelGen() {
        const L = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let n = 0;
        while (true) {
          let x = n++,
            s = "";
          do {
            s = L[x % 26] + s;
            x = Math.floor(x / 26) - 1;
          } while (x >= 0);
          yield s;
        }
      }
      let nextLabel;
      function resetLabelGen() {
        nextLabel = labelGen();
      }
      resetLabelGen(); // initial

      function makeQueue() {
        let p = Promise.resolve();
        return (fn) =>
          (p = p.then(fn).catch((e) => {
            console.warn("[queue] op failed:", e?.message || e);
          }));
      }

      async function withGattRetry(fn, { retries = 6, delay = 250 } = {}) {
        let last;
        for (let i = 0; i < retries; i++) {
          try {
            return await fn();
          } catch (e) {
            const msg = (e && e.message) || String(e);
            if (!/GATT operation already in progress/i.test(msg)) throw e;
            last = e;
            await sleep(delay * (i + 1));
          }
        }
        throw last;
      }

      function makeDieCard(diceId, label) {
        const root = document.createElement("div");
        root.className = "card";
        const title = document.createElement("h3");
        title.textContent = `Die ${label} (${shortId(diceId)})`;
        const status = document.createElement("div");
        status.className = "line";
        status.textContent = "Status: Connected";
        const battery = document.createElement("div");
        battery.className = "line";
        battery.textContent = "Battery: —";
        const roll = document.createElement("div");
        roll.className = "line";
        roll.textContent = "Last roll: —";
        root.append(title, status, battery, roll);
        diceList.appendChild(root);
        return { root, title, status, battery, roll };
      }

      // NEW: create visual dice face box
      function makeFaceCard(label) {
        const root = document.createElement("div");
        root.className = "dice-face";
        const lbl = document.createElement("div");
        lbl.className = "dice-face-label";
        lbl.textContent = `Dice ${label}`;
        const square = document.createElement("div");
        square.className = "dice-square";
        const valueEl = document.createElement("div");
        valueEl.className = "dice-square-value";
        valueEl.textContent = "-";
        square.appendChild(valueEl);
        const textUnder = document.createElement("div");
        textUnder.className = "dice-face-value";
        textUnder.textContent = "Last roll: -";
        root.append(lbl, square, textUnder);
        diceFaces.appendChild(root);
        return { root, valueEl, textUnder };
      }

      const diceState = new Map(); // diceId -> { inst, label, els, faceEls, queue, ready, batteryRequested, ledPulsed, lastActive, timer }

      const goDice = new GoDice();

      window.addEventListener("unhandledrejection", (e) => {
        const msg =
          (e && e.reason && e.reason.message) || String(e.reason || "");
        if (/GATT operation already in progress/i.test(msg)) {
          e.preventDefault();
          console.debug("[suppressed] library init race:", msg);
        }
      });

      // Inactivity (you can tweak this as you like; you mentioned ~1 minute)
      const INACTIVITY_MS = 100000;

      function markActive(diceId) {
        const st = diceState.get(diceId);
        if (!st) return;
        st.lastActive = Date.now();
        if (st.timer) clearTimeout(st.timer);
        st.timer = setTimeout(() => handleInactivity(diceId), INACTIVITY_MS);
      }

      async function handleInactivity(diceId) {
        const st = diceState.get(diceId);
        if (!st) return;
        const idleFor = Date.now() - (st.lastActive || 0);
        if (idleFor < INACTIVITY_MS - 100) {
          markActive(diceId);
          return;
        }
        st.els.status.textContent = "Status: Removed due to inactivity";
        st.els.root.classList.add("muted");
        st.queue(async () => {
          try {
            await withGattRetry(() => st.inst.disconnect?.());
          } catch (e) {
            console.warn(
              `[${st.label}] disconnect on inactivity failed:`,
              e?.message || e
            );
          } finally {
            if (st.timer) clearTimeout(st.timer);
            diceState.delete(diceId);
            if (st.els.root.parentNode)
              st.els.root.parentNode.removeChild(st.els.root);
            if (st.faceEls?.root && st.faceEls.root.parentNode)
              st.faceEls.root.parentNode.removeChild(st.faceEls.root);
            updateConnectButtonLabel();
          }
        });
      }

      // NEW: clear all dice UI elements (cards + faces)
      function clearAllDiceUI() {
        diceList.innerHTML = "";
        diceFaces.innerHTML = "";
        diceState.clear();
        updateConnectButtonLabel();
      }

      // NEW: disconnect all dice at end of session
      function disconnectAllDice() {
        const entries = Array.from(diceState.entries());
        entries.forEach(([diceId, st]) => {
          if (st.timer) clearTimeout(st.timer);
          st.els.status.textContent = "Status: Disconnected";
          st.els.root.classList.add("muted");
          st.queue(async () => {
            try {
              await withGattRetry(() => st.inst.disconnect?.());
            } catch (e) {
              console.warn(
                `[${st.label}] disconnect on endSession failed:`,
                e?.message || e
              );
            } finally {
              diceState.delete(diceId);
              if (st.els.root.parentNode)
                st.els.root.parentNode.removeChild(st.els.root);
              if (st.faceEls?.root && st.faceEls.root.parentNode)
                st.faceEls.root.parentNode.removeChild(st.faceEls.root);
            }
          });
        });
        // also reset labels so next game starts at Dice A again
        resetLabelGen();
        updateConnectButtonLabel();
      }

      GoDice.prototype.onDiceConnected = async (diceId, inst) => {
        let st = diceState.get(diceId);
        if (!st) {
          const label = nextLabel.next().value;
          const els = makeDieCard(diceId, label);
          const faceEls = makeFaceCard(label);
          const queue = makeQueue();
          st = {
            inst,
            label,
            els,
            faceEls,
            queue,
            ready: false,
            batteryRequested: false,
            ledPulsed: false,
            lastActive: Date.now(),
            timer: null,
          };
          diceState.set(diceId, st);
          console.log(`[${label}] connected id=${diceId}`);
        } else {
          st.inst = inst;
          st.els.status.textContent = "Status: Reconnected";
          st.lastActive = Date.now();
          console.log(`[${st.label}] reconnected`);
        }

        markActive(diceId);
        await sleep(2000);
        st.ready = true;

        if (!st.batteryRequested) {
          st.batteryRequested = true;
          st.queue(async () => {
            await withGattRetry(() => st.inst.getBatteryLevel());
          });
        }

        connectBtn.disabled = false;
        updateConnectButtonLabel();
      };

      GoDice.prototype.onBatteryLevel = async (diceId, level) => {
        const st = diceState.get(diceId);
        if (!st) return;
        st.els.battery.textContent = `Battery: ${level}%`;
        markActive(diceId);

        if (!st.ledPulsed && st.ready) {
          st.ledPulsed = true;
          st.queue(async () => {
            await sleep(400);
            await withGattRetry(() =>
              st.inst.pulseLed(3, 15, 15, [0, 128, 155])
            );
          });
        }
      };

      GoDice.prototype.onStable = (diceId, value /*, acc */) => {
        const st = diceState.get(diceId);
        if (!st) return;
        st.els.roll.textContent = `Last roll: ${value}`;
        markActive(diceId);

        // NEW: update visual dice box
        if (st.faceEls) {
          st.faceEls.valueEl.textContent = `${value}`;
          st.faceEls.textUnder.textContent = `Last roll: ${value}`;
        }

        // Record roll into current session
        recordRoll(diceId, st.label, value);
      };

      GoDice.prototype.onDiceDisconnected = (diceId) => {
        const st = diceState.get(diceId);
        if (!st) return;
        st.els.status.textContent = "Status: Disconnected";
        if (st.timer) clearTimeout(st.timer);
        console.log(`[${st.label}] disconnected`);
      };

      let connecting = false;
      connectBtn.addEventListener("click", async () => {
        if (connecting) return;
        if (!sessionState.active) {
          alert("Start a game session first.");
          return;
        }
        connecting = true;
        connectBtn.disabled = true;
        connectBtn.textContent = "Connecting…";
        try {
          await goDice.requestDevice();
        } catch (e) {
          alert("Connection failed: " + ((e && e.message) || e));
          connectBtn.disabled = false;
          updateConnectButtonLabel();
        } finally {
          connecting = false;
        }
      });

      /**********************************
       * INIT
       **********************************/
      populateManagerDropdown();
      updateConnectButtonLabel();
    </script>
  </body>
</html>
